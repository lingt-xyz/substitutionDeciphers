The idea behind the algorithm can be used for ciphertext-only attacks on
other simple ciphers as well. The algorithm starts by making an initial guess
about what the key is. This guess can be made on basis of a simple analysis
of the ciphertext, it can be based on partial knowledge of the key or it can
be purely random. The more correct symbols in the assumed key, the more
quickly the algorithm will converge to a solution.
The algorithm then uses this guess as a key to decrypt the ciphertext.
The resulting text is probably non-readable, but its contents will have a
certain similarity to the expected language of the plaintext depending on
how many correct symbols there were in the guess in the rst place.
In the iterated loop which follows we first alter the current key a little
bit, then this key is used to decrypt the ciphertext once again and finally
we check if the contents of the new resulting text are closer to the expected
language than those of the previously decrypted text. If they are, we keep
the new key for the next iteration, if not the old one is used but modified in
another way next time the loop is run through etc.
If we can construct a function which reflects "how close" the contents of
a given text are to the expected language we will have a working algorithm
which successively will nd more and more correct symbols. We shall later
dene such a function.
The algorithm will be explained in details only in the case of a monoalphabetic cipher. It is straightforward to generalize to a polyalphabetic cipher
- assuming that the number of alphabets used has already been determined
by some standard method, for example the Kasiski test or the index of coincidence.